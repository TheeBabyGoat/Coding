#include "cloudLayer.h.hlsl"


//-----------------------------------------------------------------------------
// Structures                                                                  
//-----------------------------------------------------------------------------

struct CloudVert
{
   float3 pos        : POSITION;
   float3 normal     : NORMAL;
   float3 binormal   : BINORMAL;
   float3 tangent    : TANGENT;
   float2 uv0        : TEXCOORD0;
};

//-----------------------------------------------------------------------------
// Main                                                                        
//-----------------------------------------------------------------------------

inline float invLerp(float from, float to, float value)
{
    return (value - from) / (to - from);
}

ConnectData main( CloudVert IN )
{   
   ConnectData OUT;

   OUT.hpos = mul(modelview, float4(IN.pos,1));

   OUT.texOffset0 = texOffset0;
   OUT.texOffset1 = texOffset1;
   OUT.texOffset2 = texOffset2;
   OUT.cloudCoverage = lerp(0.0, 1.0, invLerp(0, 5, cloudCoverage));

   // Pass light direction for volumetric cloud shadowing
   OUT.lightDir = -sunVec;

   // Transform the normal, tangent and binormal vectors from object space to 
   // homogeneous projection space:
   float3 vNormalWS   = -IN.normal;
   float3 vTangentWS  = -IN.tangent;
   float3 vBinormalWS = -IN.binormal;

   // Compute position in world space:
   float4 vPositionWS = float4(IN.pos,1) + float4( eyePosWorld, 1 ); //mul( IN.pos, objTrans );

   // Compute and output the world view vector (unnormalized):
   float3 vViewWS = eyePosWorld - vPositionWS.xyz;

   // Pass view direction for ray construction
   OUT.viewDir = normalize(vViewWS);

   // Compute denormalized light vector in world space:
   float3 vLightWS = sunVec;

   // Normalize the light and view vectors and transform it to the tangent space:
   float3x3 mWorldToTangent = float3x3( vTangentWS, vBinormalWS, vNormalWS );

   // Propagate the view and the light vectors (in tangent space):
   OUT.vLightTS = mul( vLightWS, mWorldToTangent );
   OUT.vViewTS  = mul( mWorldToTangent, vViewWS  );
   
   //OUT.worldDist = saturate( pow( max( IN.pos.z, 0 ), 2 ) );

   return OUT;
}
